//------------------------------------------------------------------------------
// <auto-generated>
//     Этот код создан инструментальным средством
//     В случае повторного создания кода изменения, внесенные в этот файл, будут потеряны.
// </auto-generated>
//------------------------------------------------------------------------------
namespace GeneralPackage.Performer
{
	using GeneralPackage.GameData;
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
    using GeneralPackage.Structures;

	public class CommandPerformer
    {
        #region attributes

        private readonly Board board;

        #endregion

        #region constructor

        public CommandPerformer(Board board)
        {
            this.board = board;
        }

        #endregion

        private bool isPathLegal(Coord start, Coord destination, int agentID) //отладить
        {
            Coord temp = new Coord();
            return !board.Walls.intersectsWalls(start, destination, out temp); //does not intersect walls
        }

    #region Agent functions

      #region IWalker

        public bool makeStep(Coord direction, double speedPercent, int agentID) //отладить
        {
            if (speedPercent <= 0) {
                return false;
            }
            Coord movementVector;
            double speed = board.Agents.getDictionary()[agentID].speed;
            if (speedPercent > 1)
            {
                movementVector = new Coord(direction.x, direction.y);
            }
            else
            {
                movementVector = new Coord(direction.x * speedPercent * speed, 
                                           direction.y * speedPercent * speed);
            }
            if (isPathLegal(board.Agents[agentID].coord, board.Agents[agentID].coord + movementVector, agentID))
            {
                Coord temp = board.Agents[agentID].coord + movementVector;
                if (!temp.inField()) {
                    return false;
                }
                board.Agents[agentID].coord = temp;
                //System.Console.Write(board.Agents[agentID].coord.ToString());
                return true;
            }
            else
            {
                return false;
            }
        }

      #endregion

      #region ISensor

        public AgentCutaway[] agentsAround(int agentID)
        {
            List<AgentCutaway> list = new List<AgentCutaway>();
            IReadOnlyDictionary<int,Agent> dict = board.Agents.getDictionary();
            Coord c =  dict[agentID].coord;
            double rad = dict[agentID].viewRadius;
            foreach (Agent ag in dict.Values)
            {
                if (ag.ID != agentID && ((c - ag.coord).norm() <= rad))
                {
                    list.Add(ag.getCutaway());
                }
            }
            return list.ToArray();
        }

        public Segment[] wallsAround(int agentID) 
        {
            List<Segment> list = new List<Segment>();
            List<Coord> sorter = new List<Coord>();
            IReadOnlyDictionary<int, Agent> dict = board.Agents.getDictionary();
            Coord c = dict[agentID].coord, beg, end;
            double R = dict[agentID].viewRadius;
            double K, C, B, X, Y;
            Segment temp = new Segment();
            foreach (Segment wall in board.Walls.getList())
            {
                beg = wall.beg - c;
                end = wall.end - c;
                if (beg.x != end.x)
                {
                    K = (beg.y - end.y) / (beg.x - end.x);
                    C = beg.y - K * beg.x;
                    B = K * K + 1;
                    if (R * R - C * C + K * K * R * R > 0)
                    {
                        X = (Math.Sqrt(-C * C + K * K * R * R + R * R) - K * C) / B;
                        Y = K * X + C;
                        temp.end.x = X + c.x;
                        temp.end.y = Y + c.y;
                        X = (-Math.Sqrt(-C * C + K * K * R * R + R * R) - K * C) / B;
                        Y = K * X + C;
                        temp.beg.x = X + c.x;
                        temp.beg.y = Y + c.y;

                        if (wall.beg.x < temp.beg.x && wall.end.x < temp.beg.x ||
                            wall.beg.x > temp.end.x && wall.end.x > temp.end.x)
                        {

                        }
                        else
                        {
                            sorter.Clear();
                            sorter.Add(wall.beg);
                            sorter.Add(wall.end);
                            sorter.Add(temp.beg);
                            sorter.Add(temp.end);
                            sorter.Sort((dot1, dot2) => dot1.x.CompareTo(dot2.x));
                            list.Add(new Segment(sorter[1], sorter[2]));
                        }
                    }
                }
                else
                {
                    if (R > beg.x)
                    {
                        X = beg.x;
                        Y = Math.Sqrt(R * R - X * X);
                        temp.end = new Coord { x = X + c.x, y = Y + c.y };
                        temp.beg = new Coord { x = X + c.x, y = -Y + c.y };
                        if (wall.beg.y < temp.beg.y && wall.end.y < temp.beg.y ||
                            wall.beg.y > temp.end.y && wall.end.y > temp.end.y)
                        {

                        }
                        else
                        {
                            sorter.Clear();
                            sorter.Add(wall.beg);
                            sorter.Add(wall.end);
                            sorter.Add(temp.beg);
                            sorter.Add(temp.end);
                            sorter.Sort((dot1, dot2) => dot1.y.CompareTo(dot2.y));
                            list.Add(new Segment(sorter[1], sorter[2]));
                        }
                    }
                }
            }
            return list.ToArray();
        }

      #endregion

    #endregion


    }
}

